* PDF plot based on tag

#+name: test-block
#+begin_src python
print("hi")
#+end_src

#+name: pdf-plot
#+begin_src python
if "paper" in _tag_.split(":"):
    plt.savefig(f"{paperdir}/figures/{figure}.pdf", bbox_inches="tight")
if "analysis" in _tag_.split(":"):
    plt.savefig(f"{figure}.pdf", bbox_inches="tight")
#+end_src

#+begin_src python
<<test-block>>
#+end_src

#+RESULTS:
: hi

** Example :paper:
:PROPERTIES:
:header-args: :var paperdir="~/tmp/scripts"
:header-args+: :var figure="test"
:header-args:python: :var "_tag_=(org-entry-get (point) \"TAGS\")"
:END:

#+begin_src sh
mkdir -p "$paperdir/figures"
#+end_src

#+RESULTS:

#+begin_src python
import matplotlib.pyplot as plt
plt.plot([1, 2])
plt.show()
<<pdf-plot>>
#+end_src

#+RESULTS:

#+begin_src sh
ls "$paperdir/figures"
#+end_src

#+RESULTS:
: test.pdf

* Python Imports

#+name: imports
#+begin_src python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import figtex;figtex.style()
import os
os.environ["USE_PROPACK"] = "1"
import scipy.sparse as sp
from scipy.sparse import linalg as spla
from mpltools import annotation
#+end_src

* Implementations
** Plot iterations
*** Average iterations
#+name: plot-avg-iter
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * .6, 3 * .6))

for problem, params in problems.items():
    avg_iter = np.loadtxt(f'{problem}/numiter.csv')
    time = np.loadtxt(f'{problem}/U.csv')[1:, 0]
    ax.plot(time, avg_iter, **params, mfc="none")
    ax.set(xlabel="time", ylabel="iterations",)
    ax.legend()
#+end_src

#+name: plot-avg-iter-new
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 1, 3 * .6))

for problem, params in problems.items():
    avg_iter = np.loadtxt(f'{problem}/numiter.csv')
    ax.plot(avg_iter[1:, 1], **params, mfc="none", ms=3, mew=.5)
    ax.set(xlabel="Time steps", ylabel="Avg. iterations p.t.s.",)
    ax.legend()
#+end_src

#+RESULTS: plot-avg-iter-new
*** Newton iterations with accumulate linear solver

#+name: plot-acc-newton-iter
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 1, 3 * .6))
axtwin = ax.twinx()

for problem, params in problems.items():
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')
    ax.plot(linear_iter[1:, 1], **params, mfc="none", ms=3, mew=.5)
    params.update(dict(ls=":", marker=None, label="newton"))
    axtwin.plot(nonlinear_iter[:, 1], **params)
    ax.set(xlabel="Time steps", ylabel="Acc. iterations p.t.s.", yscale='log')
    axtwin.set(ylabel='Nonlinear iterations')
axtwin.grid(False)
ax.legend()
#+end_src

#+name: plot-acc-newton
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 1, 3 * .8),
                       nrows=2,
                       gridspec_kw=dict(height_ratios=[4, 1]))

for problem, params in problems.items():
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')
    <<time-to-label>>
    ax[0].plot(linear_iter[1:, 1], **params, mfc="none", ms=3, mew=.5)
    params.update(dict(label="newton", mfc="none", ms=3, mew=.5))
    ax[1].plot(nonlinear_iter[:, 1], **params)
    ax[0].set(ylabel="Acc. linear iter. p.t.s.", yscale='log')
    ax[1].set(xlabel="Time steps", ylabel='Newton iter.')
ax[0].legend()
fig.tight_layout()
fig.align_ylabels()
#+end_src

#+RESULTS: plot-acc-newton
*** Iteration with convergence factor

#+name: plot-acc-conv
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 1, 3 * .8),
                       nrows=2,
                       gridspec_kw=dict(height_ratios=[4, 1]))

for problem, params in problems.items():
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    <<time-to-label>>
    ax[0].plot(linear_iter[1:, 1], **params, mfc="none", ms=3, mew=.5)
    ax[0].set(ylabel="Acc. linear iter. p.t.s.", yscale='log')

    conv = np.loadtxt(f'{problem}/conv-factor.csv')[:, 1]
    params.update(dict(label="avg", mfc="none", ms=3, mew=.5))
    ax[1].plot(conv, **params)
    ax[1].set(xlabel="Time steps", ylabel=r'Avg $\rho$ p.t.s')
ax[0].legend()
fig.tight_layout()
fig.align_ylabels()
#+end_src

*** Iteration with convergence factor and damage

#+name: plot-acc-dam
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 1, 3 * 1.2),
                       nrows=3,
                       gridspec_kw=dict(height_ratios=[4, 1, 1]))

for problem, params in problems.items():
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    <<time-to-label>>
    ax[0].plot(linear_iter[1:, 1], **params, mfc="none", ms=3, mew=.5)
    ax[0].set(ylabel="Acc. linear iter. p.t.s.", yscale='log')

    conv = np.loadtxt(f'{problem}/conv-factor.csv')[:, 1]
    params.update(dict(label="avg", mfc="none", ms=3, mew=.5))
    ax[1].plot(conv, **params)
    ax[1].set(ylabel=r'Avg $\rho$ p.t.s')

    try:
        dmg = np.loadtxt(f'{problem}/sum-damage.csv')[:, 1] 
        ax[2].plot(dmg, **params)
        ax[2].set(xlabel="Time steps", ylabel=r'$\Sigma \tilde{\alpha}_d$ p.t.s')
        ax[2].ticklabel_format(style="sci", axis="y", scilimits=(-3, 3))
    except:
        pass
        
ax[0].legend()
fig.tight_layout()
fig.align_ylabels()
#+end_src

*** Accumulated iterations per time step

#+name: plot-acc
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 1, 3 * .6))

for problem, params in problems.items():
    avg_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    ax.plot(avg_iter[1:, 1], **params, mfc="none", ms=3, mew=.5)
    ax.set(xlabel="Time steps", ylabel="Acc. iterations p.t.s", yscale='log')
    ax.legend()
#+end_src


*** Accumulated iterations and operator complexity

#+name: plot-acc-amg
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 1, 3 * 0.8),
                       nrows=2,
                       gridspec_kw=dict(height_ratios=[4, 1]))

for problem, params in problems.items():
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    operator = np.loadtxt(f'{problem}/amg-info.csv')

    <<time-to-label>>

    ax[0].plot(linear_iter[1:, 1], **params, mfc="none", ms=3, mew=.5)
    params.update(dict(marker=None, mfc="none", ms=3, mew=.5))
    ax[1].plot(operator[:, 2], **params)
    ax[0].set(ylabel="Acc. linear iter. p.t.s.", yscale='log')
    ax[1].set(ylabel='OC (nnz)')
ax[0].legend()
fig.tight_layout()
fig.align_ylabels()
#+end_src

#+RESULTS: plot-acc-newton

*** Accumulated iterations normalized by newton

#+name: plot-acc-over-newton
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * .8, 3 * .8))

for problem, params in problems.items():

    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')

    <<time-to-label>>
    ratio = linear_iter[1:, 1] / nonlinear_iter[1:, 1]
    # remove ratios that are nan, because of steps with 0 nonlinear iterations
    # ratio = np.nan_to_num(ratio, nan=0)
    ax.plot(ratio, **params, mfc="none", ms=3, mew=.5)
    params.update(dict(label="newton", mfc="none", ms=3, mew=.5))
    ax.set(xlabel="Time steps", ylabel=r"$\frac{\text{acc. linear iter.}}{\text{nonlinear iter.}}$  p.t.s.")
ax.legend()
fig.tight_layout()
#+end_src

#+RESULTS: plot-acc-over-newton


*** Accumulated iterations normalized by newton nonlocal damage variable plasticity and reaction

#+name: plot-acc-over-newton-dam-plas
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 0.8, 3 * 1.5),
                       nrows=4,
                       gridspec_kw=dict(height_ratios=[2, 2, 1, 1]))

for problem, params in problems.items():
    params.update(dict(label="none", mfc="none", ms=3, mew=.5))
    dmg = np.loadtxt(f'{problem}/sum-damage.csv')[:, 1] 
    ax[3].plot(dmg, **params)
    ax[3].set(xlabel="Time steps", ylabel=r'$\Sigma \tilde{\alpha}_d$ p.t.s')
    ax[3].ticklabel_format(style="sci", axis="y", scilimits=(-3, 3))
    threshold = 1
    nonzero_damage_id = np.where(dmg > threshold)[0]
    ax[3].axvline(nonzero_damage_id[0], color="k")

    RF = np.loadtxt(f'{problem}/RF.csv')[1:, :]
    params.update(dict(label="_none_"))
    ax[0].plot(RF[:, 0] * 100, RF[:, 1], **params)
    ax[0].set(ylabel="Reaction (N)")
    ax[0].axvline(nonzero_damage_id[0], color="k", label="localization")
    
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')
    <<time-to-label>>
    nonlinear_linear_ratio = linear_iter[1:, 1] / nonlinear_iter[1:, 1]
    ax[1].plot(nonlinear_linear_ratio, **params)
    ax[1].set(ylabel=r"$\frac{\text{Acc. linear iter.}}{\text{Newton iter.}}$  p.t.s.")
    ax[1].axvline(nonzero_damage_id[0], color="k")

    try:
        # max from all element (max gauss point value)
        # first column is the time step
        alpha_p = np.loadtxt(f'{problem}/alphaP.csv')
        ax[2].plot(np.sum(alpha_p, axis=1), **params)
        ax[2].set(ylabel=r'$\max\limits_{ele} \alpha_p$ p.t.s', yscale="log")
        ax[2].axvline(nonzero_damage_id[0], color="k")
    except:
        pass

fig.tight_layout()
#+end_src

#+RESULTS: plot-acc-over-newton-dam-plas

*** Accumulated iterations normalized by newton nonlocal damage variable and convergence

#+name: plot-acc-over-newton-dam-conv
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 0.8, 3 * 1.5),
                       nrows=3,
                       gridspec_kw=dict(height_ratios=[2, 1, 1]))

for problem, params in problems.items():
    # get non local damage data first
    # to plot on all figures
    dmg = np.loadtxt(f'{problem}/sum-damage.csv')[:, 1] 
    threshold = 1
    nonzero_damage_id = np.where(dmg > threshold)[0]

    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')
    <<time-to-label>>
    nonlinear_linear_ratio = linear_iter[1:, 1] / nonlinear_iter[1:, 1]
    params.update(dict(mfc="none", ms=3, mew=.5))
    ax[0].plot(nonlinear_linear_ratio, **params)
    ax[0].set(ylabel=r"$\frac{\text{Acc. linear iter.}}{\text{Newton iter.}}$  p.t.s.")
    ax[0].axvline(nonzero_damage_id[0], color="k")

    params.update(dict(label="none"))
    ax[1].plot(dmg, **params)
    ax[1].set(ylabel=r'$\Sigma \tilde{\alpha}_d$ p.t.s')
    ax[1].ticklabel_format(style="sci", axis="y", scilimits=(-3, 3))
    ax[1].axvline(nonzero_damage_id[0], color="k")


    conv = np.loadtxt(f'{problem}/conv-factor.csv')[1:, 1]
    params.update(dict(label="avg"))
    ax[2].plot(conv, **params)
    ax[2].set(xlabel="Time steps", ylabel=r'Avg $\rho$ p.t.s')
    ax[2].axvline(nonzero_damage_id[0], color="k")

fig.tight_layout()
#+end_src

#+RESULTS: plot-acc-over-newton-dam-plas

*** Accumulated iterations normalized by newton nonlocal damage variable

#+name: plot-acc-over-newton-dam
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 0.8, 3 * 1.5),
                       nrows=3,
                       gridspec_kw=dict(height_ratios=[2, 2, 1]))

legend = True
for problem, params in problems.items():
    params.update(dict(label="none", mfc="none", ms=3, mew=.5))
    dmg = np.loadtxt(f'{problem}/sum-damage.csv')[:, 1] 
    ax[2].plot(dmg, **params)
    ax[2].set(xlabel="Time steps", ylabel=r'$\Sigma \tilde{\alpha}_d$ p.t.s')
    ax[2].ticklabel_format(style="sci", axis="y", scilimits=(-3, 3))
    threshold = 1
    nonzero_damage_id = np.where(dmg > threshold)[0]
    ax[2].axvline(nonzero_damage_id[0], color="k")

    RF = np.loadtxt(f'{problem}/RF.csv')[1:, :]
    U = np.loadtxt(f'{problem}/U.csv')[1:, :]
    params.update(dict(label="_none_"))
    ax[0].plot(- U[:, 1], RF[:, 1], **params)
    ax[0].set(ylabel="Reaction (N)")
    ax[0].axvline(- U[nonzero_damage_id[0], 1], color="k", label=fr"$\Sigma \tilde{{\alpha}}_d=$ {threshold}")
    if legend:
        ax[0].legend()
        legend=False
    
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')
    <<time-to-label>>
    nonlinear_linear_ratio = linear_iter[1:, 1] / nonlinear_iter[1:, 1]
    ax[1].plot(nonlinear_linear_ratio, **params)
    ax[1].set(ylabel=r"$\frac{\text{Acc. linear iter.}}{\text{Newton iter.}}$  p.t.s.")
    ax[1].axvline(nonzero_damage_id[0], color="k")

    # same as nonlocal damage
    # try:
    #     # save each time step per row - 204 rows
    #     # save each element per column - 401 columns (first is the time)
    #     # save maximum omega per element
    #     omega = np.loadtxt(f'{problem}/omega.csv')[1:, 1:]
    #     # sum over all elements (axis 1 refers to the columns)
    #     sum_omega = np.sum(omega, axis=1)
    #     ax[3].plot(sum_omega, **params)
    #     ax[3].set(xlabel="Time steps", ylabel=r'$\Sigma \omega$ p.t.s')
    #     ax[3].axvline(nonzero_damage_id[0], color="k")
    # except:
    #     # raise Exception("need to rerun analysis to have savehistory for omega") from None
    #     print("need to rerun analysis to have savehistory for omega")

fig.tight_layout()
#+end_src

#+RESULTS: plot-acc-over-newton-dam-plas

*** Accumulated iterations normalized by newton nonlocal displacement

#+name: plot-acc-over-newton-displ
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * 0.8, 3 * 1),
                       nrows=2,
                       gridspec_kw=dict(height_ratios=[1, 1.5]))

legend = True
for problem, params in problems.items():
    params.update(dict(mfc="none", ms=3, mew=.5))

    U = np.loadtxt(f'{problem}/U.csv')[1:, :]
    RF = np.loadtxt(f'{problem}/RF.csv')[1:, :]

    # find peak load, when reaction starts decreasing
    peak = None
    prev = 0
    for i, r in enumerate(RF[:, 1]):
        if r < 0.999 * prev:
            peak = i
            break
        else:
            prev = r
    
    # plot vertical line when load is peak
    ax[0].axvline(- U[peak - 1, 1], label="_none_", color="k")
    ax[1].axvline(peak - 1, label="_none_", color="k")

    ax[0].plot(- U[:, 1], RF[:, 1], **params)
    ax[0].set(ylabel="Reaction (N)", xlabel="$u_y$ (mm)")
    if legend:
        # ax[0].legend()
        legend=False
    
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')
    <<time-to-label>>
    nonlinear_linear_ratio = linear_iter[1:, 1] / nonlinear_iter[1:, 1]
    ax[1].plot(nonlinear_linear_ratio, **params)
    ax[1].set(ylabel=r"$\frac{\text{Acc. linear iter.}}{\text{Newton iter.}}$  p.t.s.",
              xlabel="Time steps")

fig.tight_layout()
#+end_src

#+RESULTS: plot-acc-over-newton-dam-plas

*** Time to label

#+name: time-to-label
#+begin_src python
# add time to label
linsolve_time = np.sum(np.loadtxt(f'{problem}/time-linsolve.csv')[:, 1])
precond_time = np.sum(np.loadtxt(f'{problem}/time-precondsetup.csv')[:, 1])
total_time = linsolve_time + precond_time

time_scale = "$s$"
if total_time > 100 and total_time / 60 < 100:
    total_time /= 60
    time_scale = "$m$"
elif total_time / 60 >= 100:
    total_time /= (60 * 60)
    time_scale = "$h$"
# update params dictionary
params.update(dict(label=params.get("label","")+f" ({total_time:.1f}{time_scale})"))
#+end_src

#+RESULTS: time-to-label

** Plot time

#+name: plot-time
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(8 * .8, 3 * .6), ncols=3)

def time_to_string(time: float) -> str:
    if time > 100 and time/60 < 100:
        updated_time = time / 60
        time_scale = "$m$"
    elif time/60 >= 100:
        updated_time = time / (60 * 60)
        time_scale = "$h$"
    else:
        updated_time = time
        time_scale = "$s$"
    return f"{updated_time:.1f}{time_scale}"
        
for problem, params in problems.items():
    linsolve = np.loadtxt(f'{problem}/time-linsolve.csv')[:, 1]
    precondsetup = np.loadtxt(f'{problem}/time-precondsetup.csv')[:, 1]

    params.update(dict(mfc="none", markersize=2, mew=.5))
    label = params.get("label", "")

    params.update(dict(label=label+f" ({time_to_string(np.sum(linsolve))})"))
    ax[0].plot(linsolve, **params)
    params.update(dict(label=label+f" ({time_to_string(np.sum(precondsetup))})"))
    ax[1].plot(precondsetup, **params)
    params.update(dict(label=label+f" ({time_to_string(np.sum(linsolve)+np.sum(precondsetup))})"))
    ax[2].plot(np.cumsum(linsolve + precondsetup), **params)


ax[0].set(xlabel="Time steps", ylabel="Linear solver (s) p.t.s")
ax[0].legend(fontsize=6,handlelength=1)
ax[1].set(xlabel="Time steps", ylabel="Precond. setup (s) p.t.s")
ax[1].legend(fontsize=6, handlelength=1)
ax[2].set(xlabel="Time steps", ylabel="Cum. total time (s) p.t.s")
ax[2].legend(fontsize=6, handlelength=1)
plt.tight_layout()
#+end_src

#+RESULTS: plot-time

** Custom legend

#+name: custom-legend
#+begin_src python
from matplotlib.lines import Line2D
from matplotlib.collections import LineCollection
from matplotlib.colors import ListedColormap, BoundaryNorm
from matplotlib.legend_handler import HandlerLineCollection

                
class HandlerColorLineCollection(HandlerLineCollection):
    def create_artists(self, legend, artist ,xdescent, ydescent,
                        width, height, fontsize,trans):
        x = np.linspace(0,width,self.get_numpoints(legend)+1)
        y = np.zeros(self.get_numpoints(legend)+1)+height/2.-ydescent
        points = np.array([x, y]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)
        lc = LineCollection(segments, cmap=artist.cmap,
                            transform=trans)
        lc.set_array(x)
        lc.set_linewidth(artist.get_linewidth())
        lc.set_linestyle(artist.get_linestyle())
        lc.set_alpha(artist.get_alpha())
        return [lc]

custom_lines = []   
legend_label = []
for label, options in legend.items():
    custom_lines.append(LineCollection([[(0, 0), (0, 0)]], cmap=ListedColormap(colors), **options))
    legend_label.append(label)
                
ax.legend(custom_lines, legend_label,
          handler_map={custom_lines[0]: HandlerColorLineCollection(numpoints=len(colors)),
                       custom_lines[1]: HandlerColorLineCollection(numpoints=len(colors))})
#+end_src

** Plot displacement


#+name: plot-displ
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * .6, 3 * .6))

for problem, params in problems.items():
    rf = np.loadtxt(f'{problem}/RF.csv')[1:, 1]
    u = - np.loadtxt(f'{problem}/U.csv')[1:, 1]
    params.update(dict(mew=0.5, markersize=3, mfc='none'))
    ax.plot(u, rf / 1e3, **params)
    ax.set(ylabel="Reaction (kN)", xlabel="$u_y$ (mm)",)
    ax.legend()
#+end_src


#+name: plot-displ-zoom
#+begin_src python
<<imports>>
fig, ax = plt.subplots(figsize=(4 * .6, 3 * .6))
# inset axes
axins = ax.inset_axes(zoomax)

for problem, params in problems.items():
    params.update(dict(mew=0.5, markersize=3, mfc='none'))
    rf = np.loadtxt(f'{problem}/RF.csv')[1:, 1]
    u = - np.loadtxt(f'{problem}/U.csv')[1:, 1]
    ax.plot(u, rf/1e3, **params)
    axins.plot(u, rf/1e3, **params)
    ax.set(ylabel="Reaction (kN)", xlabel="$u_y$ (mm)",)
    ax.legend()
axins.set(xlim=zoomx, ylim=zoomy, xticks=[], yticks=[])
ax.indicate_inset_zoom(axins, edgecolor="black")
#+end_src

#+RESULTS: plot-displ-zoom
** Run

#+name: run
#+begin_src sh
echo $problem
basename "`pwd`"
mkdir -p $problem
cd $problem
edelweissfe="/home/nasser/miniconda3/envs/edelweissfe/bin/python /home/nasser/.local/src/EdelweissFE/edelweiss.py"
pueue add 'OMP_NUM_THREADS=1 '"$edelweissfe"' ../../'"$problem"'/input.inp | tee out'
git -C ~/.local/src/EdelweissFE log -n 1 | tee edelweiss-commit
#+end_src

** Run core

#+name: run-cores
#+begin_src sh
echo $problem
basename "`pwd`"
mkdir -p $problem
cd $problem
edelweissfe="/home/nasser/miniconda3/envs/edelweissfe/bin/python /home/nasser/.local/src/EdelweissFE/edelweiss.py"
OMP_NUM_THREADS=$cores $edelweissfe ../../$problem/input.inp | tee out
git -C ~/.local/src/EdelweissFE log -n 1 | tee edelweiss-commit
#+end_src
** Grab data

#+name: grab-data
#+begin_src python
<<imports>>
data = {}
for problem, params in problems.items():
    avg_iter = np.loadtxt(f'{problem}/numiter.csv')
    data[problem] = {}
    data[problem]["avg-iter"] = np.average(avg_iter[:, 1])
    # with open(f'{problem}/out') as f:
    #     lines = f.readlines()
    #     # assumes that time is the 11 from last line
    #     data[problem]["time"] = float(lines[-11].split()[4][:-1]) 
#+end_src
** Analysis plot

#+name: analysis-plot
#+begin_src python
fname=f'{figure}.pdf'
plt.savefig(fname, bbox_inches="tight")
#+end_src

** Presentation plot

#+name: presentation-plot
#+begin_src python
folders = [
    "/home/nasser/SeaDrive/My Libraries/presentations/annual-presentation-2022/figures",
    "/home/nasser/SeaDrive/My Libraries/presentations/summer-school-2022/figures",
          ]

if _tag_ == ":presentation:":
    for folder in folders:
        fname=f'{folder}/{figure}.pdf'
        plt.savefig(fname, bbox_inches="tight")
#+end_src

** PDF plot based on tag

#+name: pdf-plot
#+begin_src python
if _tag_:
    if "paper" in _tag_.split(":"):
        plt.savefig(f"{paperdir}/figures/{figure}.pdf", bbox_inches="tight")
    if "analysis" in _tag_.split(":"):
        plt.savefig(f"{figure}.pdf", bbox_inches="tight")
#+end_src


** Save dataframe to csv for paper

#+name: save-csv-paper
#+begin_src python
if _tag_ == ":paper:":
    df.to_csv(f'{paperdir}/data/{csvname}')
#+end_src

#+name: save-csv-presentation
#+begin_src python
folder =  "/home/nasser/SeaDrive/My Libraries/presentations/summer-school-2022/"

if _tag_ == ":presentation:":
    df.to_csv(f'{folder}/data/{csvname}')
#+end_src

** Average iterations for the whole simulation range over problems

#+name: average-iter-range
#+begin_src python
<<imports>>
average = []
for problem, params in problems.items():
    linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')
    average.append(np.average(linear_iter))

print(max(average) - min(average))
#+end_src

** Sparsity

#+name: sparsity
#+begin_src python
<<imports>>

fig, ax = plt.subplots(figsize=(2, 3), nrows=2, gridspec_kw=dict(height_ratios=[3, 1]))
ax[0].spy(K, marker=",", color="k", rasterized=True)
ax[0].tick_params(labeltop=False)
diag_values = np.array([(i, K[i, i]) for i in range(K.shape[0]) if K[i, i] != 1])
ax[1].plot(diag_values[:, 0],diag_values[:, 1] , '-k')
ax[1].set(ylabel="Diagonal",
          xlim=[0, K.shape[0]],
          # xticks=np.arange(0, 5001, 1000),
          # ylim=[-3.5e6, 2e6],
          # yscale='log',
          # yticks=[0,  1e1, 1e7]
          )
#+end_src

#+RESULTS: sparsity

** Generate mesh/material input

#+begin_src sh
cd ~/Experiments/sandstone-2d-micropolaronly/
problem="800-0.1"
numx=10
numy=2
gcg=0.01
mkdir -p $problem
cp base.inp  $problem/input.inp
awk -v numx=$numx -v numy=$numy -v problem=$problem -v gcg=$gcg '{sub(/num_ele_x/, numx);sub(/num_ele_y/, numy);sub(/gcgvalue/, gcg); print > problem"/input.inp"}' base.inp
#+end_src

#+RESULTS:


** Generate table

#+name: generate-table
#+begin_src python
pd.set_option('display.max_columns', None)
pd.set_option('display.precision', 1)
df = pd.DataFrame()

# collect DF row data
for dof in dofs:
    # new columns multiindex [precond, material]
    columns_id = []
    data = []
    for problem, params in problems.items():
        if dof == params["dof"]:
            # multi index columns
            columns_id.append((params["precond"], params["material"]))

            # get data for this problem
            # accumulated iterations per time step
            linear_iter = np.loadtxt(f'{problem}/numiter-acc.csv')

            nonlinear_iter = np.loadtxt(f'{problem}/nonlinear-numiter.csv')
            # linear_iter_per_nonlinear = linear_iter[:, 1] / nonlinear_iter[:, 1]

            try:
                # average accumulated iterations for the whole simulation
                # round  to floor and convert to int
                average_iter = int(np.average(linear_iter))
            except:
                # when not a single increment completed
                average_iter = "$-$"

            # save data for this dof as a string
            # data.append(f"{average_iter} ({total_precond_setup})")
            data.append(f"{average_iter}")

    # create multiindex from list of tuple
    col_multiindex = pd.MultiIndex.from_tuples(columns_id, names=["Preconditioner", r"Material ($\frac{G_c}{G}$)"])

    # create dataframe for this row
    row_df = pd.DataFrame(np.atleast_2d(data), index=[dof], columns=col_multiindex)

    # add this to the global dataframe
    df = pd.concat([df, row_df])
#+end_src

** Table setup to solver ratio

#+name: setup-to-solver-ratio
#+begin_src python
pd.set_option('display.max_columns', None)
pd.set_option('display.precision', 1)
df = pd.DataFrame()

# collect DF row data
for dof in dofs:
    # new columns multiindex [precond, material]
    columns_id = []
    data = []
    for problem, params in problems.items():
        if dof == params["dof"]:
            # multi index columns
            columns_id.append((params["precond"], params["material"]))

            # get preconditioning setup time
            precond_setup_pts = np.loadtxt(f'{problem}/time-precondsetup.csv')
            # first column is the time step
            total_precond_setup = np.sum(precond_setup_pts[:, 1])

            # get total time
            linsolve_pts = np.loadtxt(f'{problem}/time-linsolve.csv')
            total_time = np.sum(linsolve_pts[:, 1]) + total_precond_setup

            # save data for this dof as a string
            data.append(f"{( total_precond_setup / total_time * 100 ):.1f} ({total_time / 60:.1f})")
            # data.append(f"{average_iter}")

    # create multiindex from list of tuple
    col_multiindex = pd.MultiIndex.from_tuples(columns_id, names=["Preconditioner", r"Material ($\frac{G_c}{G}$)"])

    # create dataframe for this row
    row_df = pd.DataFrame(np.atleast_2d(data), index=[dof], columns=col_multiindex)

    # add this to the global dataframe
    df = pd.concat([df, row_df])
#+end_src
